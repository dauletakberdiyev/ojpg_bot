import os
import logging
import asyncio
import base64
from io import BytesIO
from datetime import datetime
from typing import Optional, Dict, Any

# Load environment variables
from dotenv import load_dotenv
load_dotenv()

from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from supabase import create_client, Client
from openai import OpenAI
import json

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class NotesBot:
    def __init__(self):
        # Initialize clients
        self.supabase: Client = create_client(
            os.getenv("SUPABASE_URL"),
            os.getenv("SUPABASE_KEY")
        )
        self.openai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        
        # Telegram bot token
        self.bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
        
        # Language translations
        self.translations = {
            "ru": {
                "welcome": "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Screenshot Notes Bot!\n\nüì∏ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ –ª—é–±–æ–π —Å–∫—Ä–∏–Ω—à–æ—Ç, –∏ —è –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É—é –µ–≥–æ, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–º–µ—Ç–∫–∏ —Å:\n‚Ä¢ –ó–∞–≥–æ–ª–æ–≤–∫–æ–º\n‚Ä¢ –¢–µ–≥–∞–º–∏\n‚Ä¢ –°–æ–¥–µ—Ä–∂–∏–º—ã–º (–∏–∑–≤–ª–µ—á–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç)\n\nüåê –î–ª—è —Å–º–µ–Ω—ã —è–∑—ã–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /language\n\nüìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n/help - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É\n/list - –ü–æ–∫–∞–∑–∞—Ç—å –≤–∞—à–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–º–µ—Ç–∫–∏\n/language - –°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫\n\n–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∏ —è —Å–¥–µ–ª–∞—é –≤—Å—ë –æ—Å—Ç–∞–ª—å–Ω–æ–µ!",
                "help": "ü§ñ –°–ø—Ä–∞–≤–∫–∞ Screenshot Notes Bot\n\nüìã –ö–æ–º–∞–Ω–¥—ã:\n/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n/list - –ü–æ–∫–∞–∑–∞—Ç—å –≤–∞—à–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–º–µ—Ç–∫–∏\n/language - –°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫\n\nüì∏ –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:\n1. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ –ª—é–±–æ–π —Å–∫—Ä–∏–Ω—à–æ—Ç\n2. –Ø –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É—é –µ–≥–æ —Å –ø–æ–º–æ—â—å—é –ò–ò\n3. –í—ã –ø–æ–ª—É—á–∏—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–º–µ—Ç–∫–∏ —Å –∑–∞–≥–æ–ª–æ–≤–∫–æ–º, —Ç–µ–≥–∞–º–∏ –∏ —Å–æ–¥–µ—Ä–∂–∏–º—ã–º\n\nüíæ –í—Å–µ –≤–∞—à–∏ –∑–∞–º–µ—Ç–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –±–µ–∑–æ–ø–∞—Å–Ω–æ!",
                "no_notes": "üìù –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–º–µ—Ç–æ–∫. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å–∫—Ä–∏–Ω—à–æ—Ç, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!",
                "recent_notes": "üìã –í–∞—à–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–º–µ—Ç–∫–∏:\n\n",
                "error_fetching": "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∑–∞–º–µ—Ç–æ–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                "processing": "üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∞—à —Å–∫—Ä–∏–Ω—à–æ—Ç...",
                "uploading": "üì§ –ó–∞–≥—Ä—É–∂–∞—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...",
                "analyzing": "ü§ñ –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å –ø–æ–º–æ—â—å—é –ò–ò...",
                "saving": "üíæ –°–æ—Ö—Ä–∞–Ω—è—é –∑–∞–º–µ—Ç–∫–∏...",
                "upload_failed": "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                "analysis_failed": "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                "save_failed": "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∑–∞–º–µ—Ç–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                "success": "‚úÖ **–°–∫—Ä–∏–Ω—à–æ—Ç —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω!**\n\nüìù **–ó–∞–≥–æ–ª–æ–≤–æ–∫:** {title}\n\nüè∑Ô∏è **–¢–µ–≥–∏:** {tags}\n\nüìÑ **–°–æ–¥–µ—Ä–∂–∏–º–æ–µ:**\n{content}\n\nüíæ –ó–∞–º–µ—Ç–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ –≤–∞—à—É –∫–æ–ª–ª–µ–∫—Ü–∏—é!\nüîó **–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ:** {image_url}",
                "error_processing": "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                "send_image": "üì∏ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å–∫—Ä–∏–Ω—à–æ—Ç –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.\n\n–Ø –º–æ–≥—É –∏–∑–≤–ª–µ—á—å —Ç–µ–∫—Å—Ç –∏ —Å–æ–∑–¥–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–º–µ—Ç–∫–∏ –∏–∑:\n‚Ä¢ –°–∫—Ä–∏–Ω—à–æ—Ç–æ–≤\n‚Ä¢ –î–æ–∫—É–º–µ–Ω—Ç–æ–≤\n‚Ä¢ –§—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ –∫–æ–¥–∞\n‚Ä¢ –õ—é–±—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å —Ç–µ–∫—Å—Ç–æ–º",
                "language_selection": "üåê –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ / –¢—ñ–ª–¥—ñ —Ç–∞“£–¥–∞“£—ã–∑ / Choose language:\n\nüá∑üá∫ –†—É—Å—Å–∫–∏–π - /lang_ru\nüá∞üáø “ö–∞–∑–∞“õ—à–∞ - /lang_kz\nüá∫üá∏ English - /lang_en",
                "language_changed": "üåê –Ø–∑—ã–∫ –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ —Ä—É—Å—Å–∫–∏–π"
            },
            "kz": {
                "welcome": "üëã Screenshot Notes Bot-“õ–∞ “õ–æ—à –∫–µ–ª–¥—ñ“£—ñ–∑!\n\nüì∏ –ú–∞“ì–∞–Ω –∫–µ–∑ –∫–µ–ª–≥–µ–Ω —Å–∫—Ä–∏–Ω—à–æ—Ç –∂—ñ–±–µ—Ä—ñ“£—ñ–∑, –º–µ–Ω –æ–Ω—ã —Ç–∞–ª–¥–∞–ø, “õ“±—Ä—ã–ª—ã–º–¥–∞–ª“ì–∞–Ω –∂–∞–∑–±–∞–ª–∞—Ä–¥—ã –∂–∞—Å–∞–π–º—ã–Ω:\n‚Ä¢ –¢–∞“õ—ã—Ä—ã–±—ã\n‚Ä¢ –¢–µ–≥—Ç–µ—Ä—ñ\n‚Ä¢ –ú–∞–∑–º“±–Ω—ã (–∞–ª—ã–Ω“ì–∞–Ω –º”ô—Ç—ñ–Ω)\n\nüåê –¢—ñ–ª–¥—ñ ”©–∑–≥–µ—Ä—Ç—É “Ø—à—ñ–Ω /language –ø–∞–π–¥–∞–ª–∞–Ω—ã“£—ã–∑\n\nüìã “ö–æ–ª –∂–µ—Ç—ñ–º–¥—ñ –∫–æ–º–∞–Ω–¥–∞:\n/start - –ë–æ—Ç–ø–µ–Ω –∂“±–º—ã—Å—Ç—ã –±–∞—Å—Ç–∞—É\n/help - –ê–Ω—ã“õ—Ç–∞–º–∞ –∫”©—Ä—Å–µ—Ç—É\n/list - –°–æ“£“ì—ã –∂–∞–∑–±–∞–ª–∞—Ä—ã“£—ã–∑–¥—ã –∫”©—Ä—Å–µ—Ç—É\n/language - –¢—ñ–ª–¥—ñ ”©–∑–≥–µ—Ä—Ç—É\n\n–¢–µ–∫ —Å—É—Ä–µ—Ç—Ç—ñ –∂—ñ–±–µ—Ä—ñ“£—ñ–∑, “õ–∞–ª“ì–∞–Ω—ã–Ω –º–µ–Ω –∂–∞—Å–∞–π–º—ã–Ω!",
                "help": "ü§ñ Screenshot Notes Bot –∞–Ω—ã“õ—Ç–∞–º–∞—Å—ã\n\nüìã –ö–æ–º–∞–Ω–¥–∞–ª–∞—Ä:\n/start - –ë–æ—Ç–ø–µ–Ω –∂“±–º—ã—Å—Ç—ã –±–∞—Å—Ç–∞—É\n/help - –û—Å—ã –∞–Ω—ã“õ—Ç–∞–º–∞–Ω—ã –∫”©—Ä—Å–µ—Ç—É\n/list - –°–æ“£“ì—ã –∂–∞–∑–±–∞–ª–∞—Ä—ã“£—ã–∑–¥—ã –∫”©—Ä—Å–µ—Ç—É\n/language - –¢—ñ–ª–¥—ñ ”©–∑–≥–µ—Ä—Ç—É\n\nüì∏ “ö–∞–ª–∞–π –ø–∞–π–¥–∞–ª–∞–Ω—É:\n1. –ú–∞“ì–∞–Ω –∫–µ–∑ –∫–µ–ª–≥–µ–Ω —Å–∫—Ä–∏–Ω—à–æ—Ç –∂—ñ–±–µ—Ä—ñ“£—ñ–∑\n2. –ú–µ–Ω –æ–Ω—ã AI –∞—Ä“õ—ã–ª—ã —Ç–∞–ª–¥–∞–π–º—ã–Ω\n3. –°—ñ–∑ —Ç–∞“õ—ã—Ä—ã–±—ã, —Ç–µ–≥—Ç–µ—Ä—ñ –∂”ô–Ω–µ –º–∞–∑–º“±–Ω—ã –±–∞—Ä “õ“±—Ä—ã–ª—ã–º–¥–∞–ª“ì–∞–Ω –∂–∞–∑–±–∞–ª–∞—Ä–¥—ã –∞–ª–∞—Å—ã–∑\n\nüíæ –ë–∞—Ä–ª—ã“õ –∂–∞–∑–±–∞–ª–∞—Ä—ã“£—ã–∑ “õ–∞—É—ñ–ø—Å—ñ–∑ —Å–∞“õ—Ç–∞–ª–∞–¥—ã!",
                "no_notes": "üìù –°—ñ–∑–¥–µ ”ô–ª—ñ –µ—à“õ–∞–Ω–¥–∞–π –∂–∞–∑–±–∞ –∂–æ“õ. –ë–∞—Å—Ç–∞—É “Ø—à—ñ–Ω –º–∞“ì–∞–Ω —Å–∫—Ä–∏–Ω—à–æ—Ç –∂—ñ–±–µ—Ä—ñ“£—ñ–∑!",
                "recent_notes": "üìã –°—ñ–∑–¥—ñ“£ —Å–æ“£“ì—ã –∂–∞–∑–±–∞–ª–∞—Ä—ã“£—ã–∑:\n\n",
                "error_fetching": "‚ùå –ñ–∞–∑–±–∞–ª–∞—Ä–¥—ã –∞–ª—É –∫–µ–∑—ñ–Ω–¥–µ “õ–∞—Ç–µ. –ö–µ–π—ñ–Ω—ñ—Ä–µ–∫ –∫”©—Ä—ñ“£—ñ–∑.",
                "processing": "üîÑ –°—ñ–∑–¥—ñ“£ —Å–∫—Ä–∏–Ω—à–æ—Ç—ã“£—ã–∑–¥—ã ”©“£–¥–µ–ø –∂–∞—Ç—ã—Ä–º—ã–Ω...",
                "uploading": "üì§ –°—É—Ä–µ—Ç—Ç—ñ –∂“Ø–∫—Ç–µ–ø –∂–∞—Ç—ã—Ä–º—ã–Ω...",
                "analyzing": "ü§ñ AI –∞—Ä“õ—ã–ª—ã —Ç–∞–ª–¥–∞–ø –∂–∞—Ç—ã—Ä–º—ã–Ω...",
                "saving": "üíæ –ñ–∞–∑–±–∞–ª–∞—Ä–¥—ã —Å–∞“õ—Ç–∞–ø –∂–∞—Ç—ã—Ä–º—ã–Ω...",
                "upload_failed": "‚ùå –°—É—Ä–µ—Ç—Ç—ñ –∂“Ø–∫—Ç–µ—É –º“Ø–º–∫—ñ–Ω –±–æ–ª–º–∞–¥—ã. “ö–∞–π—Ç–∞–ª–∞–ø –∫”©—Ä—ñ“£—ñ–∑.",
                "analysis_failed": "‚ùå –°—É—Ä–µ—Ç—Ç—ñ —Ç–∞–ª–¥–∞—É –º“Ø–º–∫—ñ–Ω –±–æ–ª–º–∞–¥—ã. “ö–∞–π—Ç–∞–ª–∞–ø –∫”©—Ä—ñ“£—ñ–∑.",
                "save_failed": "‚ùå –ñ–∞–∑–±–∞–ª–∞—Ä–¥—ã —Å–∞“õ—Ç–∞—É –º“Ø–º–∫—ñ–Ω –±–æ–ª–º–∞–¥—ã. “ö–∞–π—Ç–∞–ª–∞–ø –∫”©—Ä—ñ“£—ñ–∑.",
                "success": "‚úÖ **–°–∫—Ä–∏–Ω—à–æ—Ç —Å”ô—Ç—Ç—ñ —Ç–∞–ª–¥–∞–Ω–¥—ã!**\n\nüìù **–¢–∞“õ—ã—Ä—ã–±—ã:** {title}\n\nüè∑Ô∏è **–¢–µ–≥—Ç–µ—Ä:** {tags}\n\nüìÑ **–ú–∞–∑–º“±–Ω—ã:**\n{content}\n\nüíæ –ñ–∞–∑–±–∞ —Å—ñ–∑–¥—ñ“£ –∫–æ–ª–ª–µ–∫—Ü–∏—è“£—ã–∑“ì–∞ —Å–∞“õ—Ç–∞–ª–¥—ã!\nüîó **–°—É—Ä–µ—Ç:** {image_url}",
                "error_processing": "‚ùå –°—É—Ä–µ—Ç—Ç—ñ ”©“£–¥–µ—É –∫–µ–∑—ñ–Ω–¥–µ “õ–∞—Ç–µ –æ—Ä—ã–Ω –∞–ª–¥—ã. “ö–∞–π—Ç–∞–ª–∞–ø –∫”©—Ä—ñ“£—ñ–∑.",
                "send_image": "üì∏ –¢–∞–ª–¥–∞—É “Ø—à—ñ–Ω –º–∞“ì–∞–Ω —Å–∫—Ä–∏–Ω—à–æ—Ç –Ω–µ–º–µ—Å–µ —Å—É—Ä–µ—Ç –∂—ñ–±–µ—Ä—ñ“£—ñ–∑.\n\n–ú–µ–Ω –º“±–Ω–∞–Ω –º”ô—Ç—ñ–Ω –∞–ª—ã–ø, “õ“±—Ä—ã–ª—ã–º–¥–∞–ª“ì–∞–Ω –∂–∞–∑–±–∞–ª–∞—Ä –∂–∞—Å–∞–π –∞–ª–∞–º—ã–Ω:\n‚Ä¢ –°–∫—Ä–∏–Ω—à–æ—Ç—Ç–∞—Ä\n‚Ä¢ “ö“±–∂–∞—Ç—Ç–∞—Ä\n‚Ä¢ –ö–æ–¥ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—Ç–µ—Ä—ñ\n‚Ä¢ –ú”ô—Ç—ñ–Ω—ñ –±–∞—Ä –∫–µ–∑ –∫–µ–ª–≥–µ–Ω —Å—É—Ä–µ—Ç",
                "language_selection": "üåê –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ / –¢—ñ–ª–¥—ñ —Ç–∞“£–¥–∞“£—ã–∑ / Choose language:\n\nüá∑üá∫ –†—É—Å—Å–∫–∏–π - /lang_ru\nüá∞üáø “ö–∞–∑–∞“õ—à–∞ - /lang_kz\nüá∫üá∏ English - /lang_en",
                "language_changed": "üåê –¢—ñ–ª “õ–∞–∑–∞“õ —Ç—ñ–ª—ñ–Ω–µ ”©–∑–≥–µ—Ä—Ç—ñ–ª–¥—ñ"
            },
            "en": {
                "welcome": "üëã Welcome to Screenshot Notes Bot!\n\nüì∏ Send me any screenshot and I'll analyze it to create structured notes with:\n‚Ä¢ Title\n‚Ä¢ Tags\n‚Ä¢ Content (extracted text)\n\nüåê Use /language to change language\n\nüìã Available commands:\n/start - Start the bot\n/help - Show help information\n/list - Show your recent notes\n/language - Change language\n\nJust send an image and I'll do the rest!",
                "help": "ü§ñ Screenshot Notes Bot Help\n\nüìã Commands:\n/start - Start the bot\n/help - Show this help message\n/list - Show your recent notes\n/language - Change language\n\nüì∏ How to use:\n1. Send me any screenshot\n2. I'll analyze it with AI\n3. You'll get structured notes with title, tags, and content\n\nüíæ All your notes are saved securely!",
                "no_notes": "üìù You don't have any notes yet. Send me a screenshot to get started!",
                "recent_notes": "üìã Your recent notes:\n\n",
                "error_fetching": "‚ùå Error fetching your notes. Please try again later.",
                "processing": "üîÑ Processing your screenshot...",
                "uploading": "üì§ Uploading image...",
                "analyzing": "ü§ñ Analyzing with AI...",
                "saving": "üíæ Saving notes...",
                "upload_failed": "‚ùå Failed to upload image. Please try again.",
                "analysis_failed": "‚ùå Failed to analyze image. Please try again.",
                "save_failed": "‚ùå Failed to save notes. Please try again.",
                "success": "‚úÖ **Screenshot analyzed successfully!**\n\nüìù **Title:** {title}\n\nüè∑Ô∏è **Tags:** {tags}\n\nüìÑ **Content:**\n{content}\n\nüíæ Note saved to your collection!\nüîó **Image:** {image_url}",
                "error_processing": "‚ùå An error occurred while processing your image. Please try again.",
                "send_image": "üì∏ Please send me a screenshot or image to analyze.\n\nI can extract text and create structured notes from:\n‚Ä¢ Screenshots\n‚Ä¢ Documents\n‚Ä¢ Code snippets\n‚Ä¢ Any image with text",
                "language_selection": "üåê –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ / –¢—ñ–ª–¥—ñ —Ç–∞“£–¥–∞“£—ã–∑ / Choose language:\n\nüá∑üá∫ –†—É—Å—Å–∫–∏–π - /lang_ru\nüá∞üáø “ö–∞–∑–∞“õ—à–∞ - /lang_kz\nüá∫üá∏ English - /lang_en",
                "language_changed": "üåê Language changed to English"
            }
        }
        
    async def get_user_language(self, user_id: int) -> str:
        """Get user's preferred language, default to Russian"""
        try:
            response = self.supabase.table("user_settings").select("language").eq("user_id", user_id).execute()
            if response.data:
                return response.data[0]["language"]
            return "ru"  # Default to Russian
        except Exception as e:
            logger.error(f"Error getting user language: {e}")
            return "ru"

    async def set_user_language(self, user_id: int, language: str) -> bool:
        """Set user's preferred language"""
        try:
            # Try to update existing record
            response = self.supabase.table("user_settings").select("user_id").eq("user_id", user_id).execute()
            
            if response.data:
                # Update existing
                self.supabase.table("user_settings").update({"language": language}).eq("user_id", user_id).execute()
            else:
                # Insert new
                self.supabase.table("user_settings").insert({"user_id": user_id, "language": language}).execute()
            return True
        except Exception as e:
            logger.error(f"Error setting user language: {e}")
            return False

    def get_text(self, user_lang: str, key: str, **kwargs) -> str:
        """Get translated text for user's language"""
        text = self.translations.get(user_lang, self.translations["ru"]).get(key, key)
        if kwargs:
            return text.format(**kwargs)
        return text

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        user_id = update.effective_user.id
        user_lang = await self.get_user_language(user_id)
        welcome_message = self.get_text(user_lang, "welcome")
        await update.message.reply_text(welcome_message)

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        user_id = update.effective_user.id
        user_lang = await self.get_user_language(user_id)
        help_message = self.get_text(user_lang, "help")
        await update.message.reply_text(help_message)

    async def language_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /language command"""
        user_id = update.effective_user.id
        user_lang = await self.get_user_language(user_id)
        language_message = self.get_text(user_lang, "language_selection")
        await update.message.reply_text(language_message)

    async def set_language_ru(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Set language to Russian"""
        user_id = update.effective_user.id
        await self.set_user_language(user_id, "ru")
        message = self.get_text("ru", "language_changed")
        await update.message.reply_text(message)

    async def set_language_kz(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Set language to Kazakh"""
        user_id = update.effective_user.id
        await self.set_user_language(user_id, "kz")
        message = self.get_text("kz", "language_changed")
        await update.message.reply_text(message)

    async def set_language_en(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Set language to English"""
        user_id = update.effective_user.id
        await self.set_user_language(user_id, "en")
        message = self.get_text("en", "language_changed")
        await update.message.reply_text(message)

    async def list_notes_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /list command to show recent notes"""
        user_id = update.effective_user.id
        user_lang = await self.get_user_language(user_id)
        
        try:
            # Get recent notes for user
            response = self.supabase.table("notes").select("*").eq("user_id", user_id).order("created_at", desc=True).limit(5).execute()
            
            if not response.data:
                await update.message.reply_text(self.get_text(user_lang, "no_notes"))
                return
            
            message = self.get_text(user_lang, "recent_notes")
            for i, note in enumerate(response.data, 1):
                created_at = datetime.fromisoformat(note['created_at'].replace('Z', '+00:00'))
                formatted_date = created_at.strftime("%Y-%m-%d %H:%M")
                
                # Get tags for this note
                tags = await self.get_note_tags(note['id'])
                tags_str = ', '.join(tags) if tags else 'No tags'
                
                message += f"{i}. **{note['title']}**\n"
                message += f"   üìÖ {formatted_date}\n"
                message += f"   üè∑Ô∏è {tags_str}\n\n"
            
            await update.message.reply_text(message, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error fetching notes: {e}")
            await update.message.reply_text(self.get_text(user_lang, "error_fetching"))

    async def upload_image_to_supabase(self, image_data: bytes, filename: str) -> Optional[str]:
        """Upload image to Supabase storage"""
        try:
            # Upload to Supabase storage
            response = self.supabase.storage.from_("screenshots").upload(filename, image_data)
            
            if response:
                # Get public URL
                public_url = self.supabase.storage.from_("screenshots").get_public_url(filename)
                return public_url
            return None
            
        except Exception as e:
            logger.error(f"Error uploading image to Supabase: {e}")
            return None

    async def analyze_image_with_openai(self, image_data: bytes) -> Optional[Dict[str, Any]]:
        """Analyze image using OpenAI Vision API"""
        try:
            # Convert image to base64
            base64_image = base64.b64encode(image_data).decode('utf-8')
            
            prompt = """
            Please analyze this screenshot/image and extract structured information in the following JSON format:
            
            {
                "title": "A descriptive title for the content (max 100 chars)",
                "tags": ["tag1", "tag2", "tag3"],
                "content": "All readable text from the image, organized and formatted clearly"
            }
            
            Guidelines:
            - Title should be descriptive and capture the main topic/purpose
            - Tags should be relevant keywords (max 3 tags)
            - Content should include ALL readable text, maintaining structure when possible
            - If it's a code screenshot, preserve code formatting
            - If it's a document, maintain paragraph structure
            - If text is unclear, indicate with [unclear text]
            
            Return only valid JSON.
            """
            
            response = self.openai_client.chat.completions.create(
                model="gpt-5-mini",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}",
                                    "detail": "high"
                                }
                            }
                        ]
                    }
                ]
            )
            
            # Parse JSON response
            content = response.choices[0].message.content.strip()
            
            # Clean up response (remove markdown code blocks if present)
            if content.startswith('```json'):
                content = content[7:-3].strip()
            elif content.startswith('```'):
                content = content[3:-3].strip()
            
            return json.loads(content)
            
        except Exception as e:
            logger.error(f"Error analyzing image with OpenAI: {e}")
            return None

    async def save_note_to_db(self, user_id: int, username: str, note_data: Dict[str, Any], image_url: str) -> bool:
        """Save note to Supabase database with separate tags table"""
        try:
            # Prepare data for notes table (without tags)
            note_db_data = {
                "user_id": user_id,
                "username": username,
                "title": note_data["title"],
                "content": note_data["content"],
                "image_url": image_url,
                "created_at": datetime.now().isoformat()
            }
            
            # Insert into notes table and get the ID
            notes_response = self.supabase.table("notes").insert(note_db_data).execute()
            
            if not notes_response.data or len(notes_response.data) == 0:
                return False
                
            note_id = notes_response.data[0]["id"]
            
            # Insert tags into note_tags table
            if note_data.get("tags"):
                tag_data = []
                for tag in note_data["tags"]:
                    if tag.strip():  # Only add non-empty tags
                        tag_data.append({
                            "note_id": note_id,
                            "tag": tag.strip()
                        })
                
                if tag_data:  # Only insert if there are valid tags
                    self.supabase.table("note_tags").insert(tag_data).execute()
            
            return True
            
        except Exception as e:
            logger.error(f"Error saving note to database: {e}")
            return False

    async def get_note_tags(self, note_id: int) -> list:
        """Get all tags for a specific note"""
        try:
            response = self.supabase.table("note_tags").select("tag").eq("note_id", note_id).execute()
            return [tag_row["tag"] for tag_row in response.data] if response.data else []
        except Exception as e:
            logger.error(f"Error fetching note tags: {e}")
            return []

    async def handle_image(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle incoming images"""
        user_id = update.effective_user.id
        username = update.effective_user.username or f"user_{user_id}"
        user_lang = await self.get_user_language(user_id)
        
        # Send processing message
        processing_msg = await update.message.reply_text(self.get_text(user_lang, "processing"))
        
        try:
            # Get the largest photo size
            photo = update.message.photo[-1]
            
            # Download image
            file = await photo.get_file()
            image_data = await file.download_as_bytearray()
            
            # Update processing message
            await processing_msg.edit_text(self.get_text(user_lang, "uploading"))
            
            # Generate filename
            timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
            filename = f"{user_id}{timestamp}.jpg"
            
            # Upload to Supabase storage
            image_url = await self.upload_image_to_supabase(bytes(image_data), filename)
            if not image_url:
                await processing_msg.edit_text(self.get_text(user_lang, "upload_failed"))
                return
            
            # Update processing message
            await processing_msg.edit_text(self.get_text(user_lang, "analyzing"))
            
            # Analyze with OpenAI
            analysis_result = await self.analyze_image_with_openai(bytes(image_data))
            if not analysis_result:
                await processing_msg.edit_text(self.get_text(user_lang, "analysis_failed"))
                return
            
            # Update processing message
            await processing_msg.edit_text(self.get_text(user_lang, "saving"))
            
            # Save to database
            saved = await self.save_note_to_db(user_id, username, analysis_result, image_url)
            if not saved:
                await processing_msg.edit_text(self.get_text(user_lang, "save_failed"))
                return
            
            # Format response message with image URL
            content_preview = analysis_result['content'][:1000]
            if len(analysis_result['content']) > 1000:
                content_preview += "..."
                
            response_message = self.get_text(
                user_lang, 
                "success",
                title=analysis_result['title'],
                tags=', '.join(analysis_result['tags']),
                content=content_preview,
                image_url=image_url
            )
            
            await processing_msg.edit_text(response_message, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error handling image: {e}")
            await processing_msg.edit_text(self.get_text(user_lang, "error_processing"))

    async def handle_non_image(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle non-image messages"""
        user_id = update.effective_user.id
        user_lang = await self.get_user_language(user_id)
        await update.message.reply_text(self.get_text(user_lang, "send_image"))

    def create_application(self) -> Application:
        """Create and configure the Telegram bot application"""
        application = Application.builder().token(self.bot_token).build()
        
        # Add handlers
        application.add_handler(CommandHandler("start", self.start_command))
        application.add_handler(CommandHandler("help", self.help_command))
        application.add_handler(CommandHandler("list", self.list_notes_command))
        application.add_handler(CommandHandler("language", self.language_command))
        application.add_handler(CommandHandler("lang_ru", self.set_language_ru))
        application.add_handler(CommandHandler("lang_kz", self.set_language_kz))
        application.add_handler(CommandHandler("lang_en", self.set_language_en))
        application.add_handler(MessageHandler(filters.PHOTO, self.handle_image))
        application.add_handler(MessageHandler(~filters.PHOTO, self.handle_non_image))
        
        return application

def setup_database():
    """Setup database table if it doesn't exist"""
    try:
        # This would typically be done via Supabase dashboard or migrations
        # But here's the SQL for reference:
        create_tables_sql = """
        -- Create notes table (removed tags array column)
        CREATE TABLE IF NOT EXISTS notes (
            id SERIAL PRIMARY KEY,
            user_id BIGINT NOT NULL,
            username VARCHAR(255),
            title VARCHAR(500) NOT NULL,
            content TEXT NOT NULL,
            image_url TEXT NOT NULL,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        );
        
        -- Create note_tags table for normalized tag storage
        CREATE TABLE IF NOT EXISTS note_tags (
            id SERIAL PRIMARY KEY,
            note_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
            tag VARCHAR(100) NOT NULL,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        );
        
        -- Create user_settings table for language preferences
        CREATE TABLE IF NOT EXISTS user_settings (
            id SERIAL PRIMARY KEY,
            user_id BIGINT UNIQUE NOT NULL,
            language VARCHAR(2) DEFAULT 'ru',
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        );
        
        -- Create indexes for better performance
        CREATE INDEX IF NOT EXISTS idx_notes_user_id ON notes(user_id);
        CREATE INDEX IF NOT EXISTS idx_notes_created_at ON notes(created_at DESC);
        CREATE INDEX IF NOT EXISTS idx_note_tags_note_id ON note_tags(note_id);
        CREATE INDEX IF NOT EXISTS idx_note_tags_tag ON note_tags(tag);
        CREATE INDEX IF NOT EXISTS idx_user_settings_user_id ON user_settings(user_id);
        
        -- Create unique constraint to prevent duplicate tags for the same note
        CREATE UNIQUE INDEX IF NOT EXISTS idx_note_tags_unique ON note_tags(note_id, tag);
        """
        
        print("Database tables should be created manually in Supabase with the following structure:")
        print(create_tables_sql)
        
    except Exception as e:
        logger.error(f"Database setup note: {e}")

def main():
    """Main function to run the bot"""
    # Check environment variables
    required_vars = ["TELEGRAM_BOT_TOKEN", "SUPABASE_URL", "SUPABASE_KEY", "OPENAI_API_KEY"]
    missing_vars = [var for var in required_vars if not os.getenv(var)]
    
    if missing_vars:
        logger.error(f"Missing required environment variables: {', '.join(missing_vars)}")
        return
    
    # Setup database (informational)
    # setup_database()
    
    # Create and run bot
    bot = NotesBot()
    application = bot.create_application()
    
    logger.info("Starting Telegram Screenshot Notes Bot...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()